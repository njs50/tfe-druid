<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>spell improve path</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>saw combat</name>
				<script>improves = improves or {}
improves.sawAction = true
cecho('\n\n&lt;green&gt;IMPROVES: &lt;white&gt;saw some action!\n\n')


if (improves.actionRelease) then
  killTimer(improves.actionRelease)
end
send('sleep')
improves.actionRelease = tempTimer(40, function()
  send('stand &amp; |scan')
  improves.actionRelease = nil
  improves.sawAction = nil
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You receive \d+ experience points\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>x's size makes it easy for it to avoid the thick vines.</name>
				<script>tempTimer(3, function()
  send('cast undergrowth')
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>avoid the thick vines\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>drink from puddles</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>A small puddle containing a clear liquid seems to bubble up from the ground.</string>
				<string>A large puddle containing a clear liquid seems to bubble up from the ground.</string>
				<string>A very large puddle containing a clear liquid seems to bubble up from the ground.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>2</integer>
				<integer>2</integer>
				<integer>2</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>khiren - hidden</name>
			<script>expandAlias('unhide')
send('yell khiren')</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>seeing no one, he retreats back to his forge.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>landbinding failed</name>
			<script>tfe = tfe or {}
tfe.supressNextRoomChange = true
send('queue cast landwalk &amp; cast landbinding')</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Your skill as a landbinder fails you...</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>2</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>landbinding</name>
			<script>send('cast landbinding')</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Nothing found matching "nexus".</string>
				<string>^You can see the \w+ \w+, but the \w+\.\.\.  bends\.\.\. </string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>2</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>respell</name>
			<script>expandAlias('respell gstat')</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.* reports? group status[^:]*:\s+"respell"$</string>
				<string>^.* tells? the group[^:]*:\s+"respell"$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>autohide</name>
			<script>if (gmcp and gmcp.Room and gmcp.Room.Info) then
  
  local hiding = table.contains(gmcp.Char.Status.flags, 'hiding')
  local fighting = #table.keys(gmcp.Char.Fighting) &gt; 0
  local cantHide = false
  
  local noHideRooms = {
    ['170'] = true,
    ['107'] = true,
    ['5117'] = true,
    ['5113'] = true,
    ['3817'] = true,
    -- ['5880'] = true, -- using snakeskins for resist = no hiding
  }
  
  
  -- no hiding in the soup room or safe rooms
  if (gmcp.Char.Status.position ~= 'sleeping' and (noHideRooms[tostring(gmcp.Room.Info.num)] or table.contains(gmcp.Room.Info.flags, 'safe'))) then
    cantHide = true
    if (hiding) then 
      send('unhide')
    end
  end
  
  -- no need to hide in safe rooms
  
  
  -- display(hiding,fighting,cantHide)
  
  -- make sure we have checked out equip before autohide is enabled
  if (player and player.gear) then
        
    if catalog.isWearing('snakeskin bracer of elemental resistance') then
      cantHide = true
    
    elseif catalog.isWearing({'snakeskin bracer of elemental resistance', 'rune-inscripted snakeskin bracer'}) then
      cantHide = true
   
    elseif catalog.isWearing({'ivory boots'}) then
      cantHide = true

    elseif catalog.isWearing({'engemmed fiery red cloak', 'cloak of flames'}) then
      cantHide = true
    end    

    if (gmcp.Char.Status.position == 'sleeping' or
        gmcp.Char.Status.position == 'wading' or
        gmcp.Char.Status.position == 'resting' or
        gmcp.Char.Status.position == 'mounted' or
        gmcp.Char.Status.position == 'swimming'
    ) then
      cantHide = true
    end
    
    if (player.unhide == true) then
      cantHide = true
    end
    
    
    if (not hiding and not fighting and not cantHide) then
      cecho('\n&lt;green&gt;AUTOHIDE:&lt;white&gt; time to hide!')
      send('hide')
      disableTrigger('autohide')
      tempTimer(1.5, function()
        enableTrigger('autohide')
      end, 'disable autohide')
    end
  
  end
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^&lt;</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>darklight</name>
			<script>cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; recasting darklight\n\n')
common.getManaAndCast(50, 'darklight', '', true)


-- You can no longer sense your surroundings without light.</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Nothing found matching "darklight".</string>
				<string>Your darklight's energy is beginning to fade.</string>
				<string>Your darklight is about to fade.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>2</integer>
				<integer>2</integer>
				<integer>2</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>hide failed</name>
			<script>send('hide')</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>You fail to step into the shadows.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>2</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>leveling</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>landbinding</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>infinite nexus</name>
					<script>send('enter nexus')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^You bind the entrance to .* and enter\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>imp landbinding</name>
					<script>cecho('\n&lt;green&gt;IMPS:&lt;white&gt; queued landbind/walk etc\n\n')

local spell = 'cast landbinding &amp; cast landwalk &amp; enter nexus'

if (player.skills.landbinding &lt; 10 and not table.contains(improves.castQueue, spell)) then
  improves.queueSpell(spell)
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Your skill as a landbinder fails you...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>bandage fail</name>
				<script>expandAlias('imp-bandage')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You try to bandage your own wounds but just make the situation worse.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>snack break</name>
				<script>local vessel = player.vessel or 'leather.waterskin'

send('drink ' .. vessel .. ' &amp; drink ' .. vessel .. ' &amp; drink ' .. vessel .. ' &amp; queue give empty.' .. vessel .. ' ' .. group.leader)
send('gstat snack me')
send('eat food &amp; eat food &amp; eat food &amp; eat food')
send('drop all.food &amp; get 4*food')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.* reports group status[^:]*:\s+"snack break"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>get full</name>
				<script>player.gettingFull = player.gettingFull or false

if (not player.gettingFull) then
	player.gettingFull = true
  send('ef &amp; dw &amp; dismount')

  tempTimer(2, function ()
  	send('sit couch &amp; sit chair &amp; sit pad &amp; sit boulder')
  	expandAlias('sl')
  	common.onFull( function ()
			expandAlias('st')
      send('mount')
    	-- expandAlias('give all.coin batso &amp; drop all.food &amp; get 2*food')

  		tempTimer(3, function ()
				player.gettingFull = false
  			expandAlias('gstat ready (' .. player.name .. ')')
  		end)

    end)
  end)

else
	cecho('\n&lt;green&gt;PREP: &lt;white&gt;already getting full\n')
end

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.* reports group status[^:]*: "(pfull|get full)"</string>
					<string>^.* tells? (?:your|the) group[^:]*: "(pfull|get full)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>reagents</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>A grain of sand lies almost invisible on the ground.</name>
				<script>send('get sand &amp; put 2.sand ' .. player.pack)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A grain of sand lies almost invisible on the ground.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>A pinch of mica glitters on the ground.</name>
				<script>send('get mica &amp; put mica ' .. player.pack)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A pinch of mica glitters on the ground.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>get sage</name>
				<script>send('get sage &amp; put sage morel')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A handful of sage, cedar, and cinnamon lies here in a small clump.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>druid - healing</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>heal casting</name>
				<script>druid.healCastStart()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You begin casting healing rain.</string>
					<string>You begin casting healing mist.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>heal cast</name>
				<script>druid.healStarted()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>+++ You cast healing rain +++</string>
					<string>+++ You cast healing mist +++</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>heal finished</name>
				<script>druid.healEnded()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The healing mists evaporate.</string>
					<string>The healing rains disperse.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>storm interrupted</name>
				<script>druid.healInterrupted()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^&gt;&gt; Your healing (rain|mist) casting is disrupted\. &lt;&lt;</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>in combat fail</name>
				<script>druid.healCombatFail()
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You cannot cast (healing rain|healing mist) while fighting\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>druid healing command</name>
				<script>if (player.healingEnabled) then
  
  local from = matches[2]
  
  local chan = matches[3]
  
  local target = matches[4]
  
  if chan == 'tell' then
    chan = chan .. ' ' .. matches[2]
  end
  
  if chan == 'tells the group' then
    chan = 'gstat'
  end
  
  if chan == 'group status' then
    chan = 'gstat'
  end
  
  
  if (target ~= 'you' and #target &gt;= 2 and rex.match(player.name:lower(), target:lower())) then
    target = 'you'
  end
    
  if (target == 'you') then
  
    cecho('\n\nheal group\n\n')
    druid.healGroup({
      skipAmount = 150,
      callback = function()  
        send(chan .. ' group healed') 
      end
    })
    
  end
  
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) (tell)s (you): "heal group"$</string>
					<string>^(.+?) reports? (group status): "(\w+) heal group"</string>
					<string>^(.+?) (tells? the group): "(\w+) heal group"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>druid - storm</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>storm ended</name>
				<script>-- cecho('\n&lt;green&gt;storm state:&lt;white&gt; storm ended\n')

if (player.stormEnabled) then

  player.ss.storm_active = nil
  cecho('&lt;green&gt; &lt;-- &lt;white&gt;ss end')
  -- display(gmcp.Char)
  
  
  -- start a new storm if we are still in combat
  -- if end of combat is pending then check again in 1.1 seconds
  if (combat.finishPending) then
    tempTimer(1.1, function()
      if (combat.active) then
        player.ss.cast(cancelQueue)
      else
        raiseEvent(player.ss.events.STORM_ENDED)
      end
    end)
  else
    if (combat.active) then
      player.ss.cast(cancelQueue)
    else
      raiseEvent(player.ss.events.STORM_ENDED)
    end
  end
  
 end
 </script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The rolling black clouds fade to grey and dissipate</string>
					<string>The black and grey funnel clouds disappear like mist</string>
					<string>The heavy grey clouds of the blizzard melt away into the air</string>
					<string>The strange storm dissipates as quickly as it appeared</string>
					<string>The small squall dissipates as quickly as it appeared</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>casting storm</name>
				<script>if (player.stormEnabled) then
  
  player.ss.casting = true
  -- player.ss.storm_active = false
  cecho('&lt;green&gt; &lt;-- &lt;white&gt; ss casting')
  
 end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You begin casting (tempest|tornado|blizzard|storm|squall)\.</string>
					<string>^\[ Queued \d+:\s+(queue\s*)?cast (tempest|tornado|blizzard|storm|squall)\s+\]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>cast storm</name>
				<script>if (player.stormEnabled) then
  
  player.ss.casting = false
  player.ss.storm_active = true
  cecho('&lt;green&gt; &lt;-- &lt;white&gt; ss cast')
 
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\+\+\+ You cast (tempest|tornado|blizzard|storm|squall) \+\+\+</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>storm interrupted</name>
				<script>local target = matches[2]

if (player.stormEnabled) then
  
  player.ss.casting = false
  cecho('&lt;green&gt; &lt;-- &lt;white&gt; ss disrupt')
  player.ss.cast()
  
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^&gt;&gt; Your (tempest|tornado|blizzard|storm|squall) casting is disrupted\. &lt;&lt;</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>storm prep interrupted</name>
				<script>-- &gt;&gt; Your tempest preparation is disrupted. &lt;&lt;
local target = matches[2]

common.onClear(function()
  send('prepare ' .. target)
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^&gt;&gt; Your (tempest|tornado|blizzard|storm|squall) preparation is disrupted\. &lt;&lt;</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>augments</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>augmented item</name>
				<script>
-- You are not experienced enough to augment a singular crimson armlet.
-- An elongated slarg rib is absorbed into the ivy...
-- You hold a shimmering slarg silk cloak in your hands.
-- You hold a singular copper-inset singular crimson armlet in your hands.

  druid.aug.createdItem = common.dotCase(common.itemSanitize(matches[4]))
  -- display(druid.aug)


-- augment failed...
-- A zinc ingot is absorbed into the vines...
-- The vines begins to constrict a roll of medicated tape, but then receeds, leaving it as it was.
-- The ivy begins to constrict a glass-scale anklet, but then receeds, leaving it as it was.</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(You) (create) (.*)\.$</string>
					<string>^(You) (hold) (.*) in your hands\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>augment tell</name>
				<script>druid.aug = druid.aug or {}


-- Nothing found matching "vine".

if (not player.skills['vine armor'] or player.skills['vine armor'] == 0) then
  send('tell ' .. matches[2] .. ' I am not qualified to augment items')
  return
end


if (gmcp.Room.Info.num ~= druid.augRoom) then
  send('tell ' .. matches[2] .. ' I am not currently in the designated aug bot waiting room')
  return
end


if (matches[3] == 'ivy' or matches[3] == 'vine') then
  
  if not druid.aug.pending then
    
    druid.aug = {
      vic = matches[2],
      spell = matches[3],
      terrain = matches[4]:lower(),
      item = matches[5],
      pending = true
    }
    
    druid.aug.fuckedOutTimer = tempTimer(90, function()
      
      tfe.gotoRoom(druid.augRoom, function()
        druid.aug.pending  = false
        send('tell ' .. druid.aug.vic .. ' something went horribly wrong, you might need to try that again')
        send('give ' .. druid.aug.item .. ' ' .. druid.aug.vic)
      end)
      
    end)
    
    send('tell ' .. druid.aug.vic .. ' your augment is queued, don\'t leave the soup room or i\'ll keep your shit!')
    
    druid.augment(druid.aug.spell, druid.aug.terrain, druid.aug.item, function()
      send('unhide &amp; tell ' .. druid.aug.vic .. ' augment done!')
      druid.aug.pending = false
      killTimer(druid.aug.fuckedOutTimer)
      send('give ' .. (druid.aug.createdItem or druid.aug.item) .. ' ' .. druid.aug.vic) 
    end, function(msg)
      send('unhide &amp; tell ' .. druid.aug.vic .. ' augment failed! ' .. msg)
      send('give ' .. druid.aug.item .. ' ' .. druid.aug.vic) 
      druid.aug.pending = false
      killTimer(druid.aug.fuckedOutTimer)
    end)
    
    
  else
  
    send('tell ' .. matches[2] .. ' I currently have an augment queued for ' .. druid.aug.vic .. ' . try again later...')
  
  end
  
else

  send('tell ' .. matches[2] .. ' tell me "aug &lt;vine|ivy&gt; &lt;terrain&gt; &lt;item&gt;" after you\'ve given me the goods')

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([A-Za-z]+) tells you:\s*"aug (vine|ivy) (jungle|beach|cave|forest|bamboo|tundra|desert|hills|field|swamp|mountain) (.*)"$</string>
					<string>^([A-Za-z]+) tells you:\s*"aug ?(.*)"$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>aug fucks out</name>
				<script>-- The vines begins to constrict a roll of medicated tape, but then receeds, leaving it as it was.
-- The ivy begins to constrict a glass-scale anklet, but then receeds, leaving it as it was.

-- The ivy will not grow around a pair of gloves of deftness, and it recedes from it.

druid.aug.createdItem = common.dotCase(common.itemSanitize(matches[2]))

if (matches[4] == 'leaving it') then
  send('tell ' .. druid.aug.vic .. ' looks like your reagent was consumed :-[')
end

if (matches[3] == 'recedes from it') then
  send('tell ' .. druid.aug.vic .. ' looks like your recipe was fucked. sometimes it needs vine instead of ivy armor')
end

send('tell ' .. druid.aug.vic .. ' ' .. matches[1])
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^The (vines|ivy) begins to constrict (.*), but then receeds, (leaving it) as it was\.</string>
					<string>^The ivy will not grow around (.*),  and it (recedes from it).</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>aug missing reagent</name>
				<script>
-- Your druidic senses feel that something is missing...  another ethergem.

send('tell ' .. druid.aug.vic .. ' ' .. matches[1])
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Your druidic senses feel that something is missing...  (.*).</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Nothing found matching "gem bright".</name>
				<script>if (druid and druid.aug and druid.aug.item) then
  
  local target = druid.aug.item:gsub("\."," ")
  
  if matches[2] == druid.aug.item then
    send('tell ' .. druid.aug.vic .. ' looks like you told me to augment something i don\'t have')
    send('tell ' .. druid.aug.vic .. ' ' .. matches[1])
  end

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Nothing found matching "(.*)"\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>prep free</name>
			<script>cecho('\n&lt;green&gt;PREP: &lt;white&gt; prepping free mana\n')

expandAlias('xerotes')

druid.prepFree(function()
  send('|gstat ready (' .. player.name .. ')')
end)
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "(prep free|pfree)"</string>
				<string>^You tell your group[^:]*: "(prep free|pfree)"</string>
				<string>^.* reports? group status[^:]*: "(prep free|pfree)"</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>get full</name>
			<script>druid.getFull(function()
  send('gstat ready (' .. player.name .. ')')
end)


</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.* reports? group status[^:]*: "(pfull|get full)"</string>
				<string>^.* tells? (?:your|the) group[^:]*: "(pfull|get full)"</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>get ready</name>
			<script>expandAlias('getReady')</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.* tells? (?:your|the) group[^:]*: "get ready"</string>
				<string>^.* reports? group status[^:]*: "get ready"</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>dead thing - report juice</name>
			<script>-- send('skin corpse &amp; eat corpse &amp; get all &amp; drop all.corpse')
-- send('eat corpse')
-- send('get all 1.corpse &amp; get all 2.corpse &amp; get all 3.corpse &amp; get all &amp; drop all.corpse')

druid.reportMana()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^You receive \d+ experience points.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>stand up now!</name>
			<script>expandAlias('upp')</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(An? .+?|The .+?|\w+) reports? group status[^:]*: "up"</string>
				<string>^(An? .+?|The .+?|\w+) tells? the group[^:]*: "up"</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>xerotes</name>
			<script>gmcp.Room.Info.wind = 'storm'</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>+++ You cast xerotes +++</string>
				<string>^\w+ casts xerotes\.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>2</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>time check</name>
			<script>
local sleepTrig = tempRegexTrigger([[^You cannot do that while sleeping\.$]], function()
  send('stand &amp; observe &amp; sleep')
end, 1)

tempRegexTrigger([[^=\s+(\S.*?)\s+\|\s*(\S.*?)\s*=]], function()
  display(matches[2], matches[3])
  send('cstat it is ' .. matches[3] .. ' on ' .. matches[2])
  killTrigger(sleepTrig)
end,1)
send('observe')
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.* reports? clan status: "time"$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>assist changed</name>
			<script>send('gstat assist set to: ' .. matches[2])</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^You will auto.assist with (.*)\.</string>
				<string>^Your auto.assist skill has been set to (none)\.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>cant use while hiding</name>
			<script>-- You can't use 2 snakeskin bracers of elemental resistance while hiding.

expandAlias('unhide')
resetGear()

</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^You can't use .* while hiding\.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>respell</name>
			<script>-- send('stand')
expandAlias('respell')</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>respell improves</name>
			<script>cecho('\n\nchecking buffs!\n\n')
njs50.respell(player.buffs, {queueSpellImprove = true})</script>
			<command></command>
			<packageName></packageName>
			<time>00:02:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>cast improve spell w/tobacco for buffs</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')
improves.setFiller(druid.improveNonCombat)

send('stand')

if (#improves.castQueue &gt; 0) then

  if (improves.castFillerLastTick) then
    
    improves.castSpell()
  
  else

    murder.smokeUp('imps-no-wis','imps-regen', 22, function()
      local message = '[improves] : ' .. improves.castQueue[1]
      common.consoleMessage('Log', message, 'green', true)
      improves.castSpell() 
    end)
    
  end
  
else
  improves.castSpell(function()
    send('|drink cauldron')
    send('|sit couch &amp; |sleep')
  end)
end







improves.resetFiller()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:45.100</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve spells w/ druid non combat improve filler</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')

improves.setFiller(druid.improveNonCombat)

send('stand')
improves.castSpell(function()
  send('|drink cauldron &amp; |sit couch &amp; |sleep')
end)

improves.resetFiller()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:45.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>kick/swim while no improve casts queued</name>
			<script>-- local cmd = 'queue dive pool &amp; queue climb chain'
local cmd = '|kick stand &amp; |kick stand &amp; |kick stand'

-- local cmd = '|punch bag &amp; |punch bag &amp; |punch bag'

if (#improves.castQueue == 0) then
  send(cmd)
else
  
  if (improves.castFillerLastTick ~= false) then
    improves.castFillerLastTick = false
    tempTimer(65, function()
      send('+')
      murder.smokeUp('imps-no-wis','imps', 12, function()
        improves.castSpell()
        send('wait 3')
      end)
    end, 'casting buff delay')
  end
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.100</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>cast improve spell</name>
			<script>send(improves.getImproveSpell())</script>
			<command></command>
			<packageName></packageName>
			<time>00:01:05.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>drink cauldron + smoke</name>
			<script>
-- local timer = 'moj base pracs'
local timer = 'kick/swim while no improve casts queued'

disableTimer(timer)


send('drink cauldron')

murder.checkPracs(function(pracs)

  if (pracs &gt; 150) then
    cecho('\n\nto many pracs!\n\n')
    -- send('cstat got to 300 prac points, quitting for now...')
    -- send('quit')
    return
  else  
    cecho('\n&lt;green&gt;IMPROVE BOT:&lt;white&gt; acquired ' .. tostring(pracs) .. ' prac points so far\n\n')
    murder.smokeUp('nowis','imps', 12, function()
      enableTimer(timer)
    end)
    
  end

end)
</script>
			<command></command>
			<packageName></packageName>
			<time>00:02:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve ticker w/ sleep + drink</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')

send('stand &amp; |drink trough &amp; |inventory')

improves.castSpell()

tempTimer(7, function()
  send('|sit couch &amp; |sleep')
end, 'pending imp attempt')</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:45.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve ticker w/tobacco</name>
			<script>cecho('\n&lt;white&gt;Improve - halftick\n')
-- send('stand')

if (#improves.castQueue &gt; 0) then

  murder.smokeUp('nowis','imps', 22, function()
    tempTimer(3,function()
      improves.castSpell()
      -- send('sit couch &amp; sleep')
    end)    
  end)
  
else
  improves.castSpell()
  -- send('sit couch &amp; sleep')
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:35.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve dowse</name>
			<script>send('cast dowse &amp; queue fill waterskin puddle &amp; queue empty waterskin &amp; queue fill waterskin puddle &amp; queue empty waterskin')</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:35.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>get pracs</name>
			<script>local cmd = 'dive pool &amp; climb chain &amp; climb chain'

murder.checkNum = ((murder.checkNum or 0) + 1) % 10

if murder.checkNum == 0 then
  disableTimer('get pracs')
  murder.checkPracs(function(pracs)
  
  
  
    if (pracs &gt; 595) then
      cecho('\n\ntoo many pracs!\n\n')
      send('cstat got to 595 prac points, quitting for now...')
      send('quit')

      return
    else  
      enableTimer('get pracs')
      cecho('\n&lt;green&gt;IMPROVE BOT:&lt;white&gt; acquired ' .. tostring(pracs) .. ' prac points so far\n\n')
    end
  
  end)
else
  send(cmd)
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.250</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>improve landwalk</name>
			<script>send('stand')

if (player.skills.landwalk &lt; 10) then
  tfe.gotoRoom(28112, function()
  
    send('gl &amp; ef &amp; dw &amp; pl &amp; queue cast landwalk')
    -- murder.smokeUp('imps-reg','imps', 10, function()
      -- send('queue hide &amp; queue sleep')
    -- end)
    tempTimer(3, function()
      send('queue hide &amp; queue sleep')
    end)
    
  end)
  
else 

  tfe.gotoRoom({28112, 170})
  
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:45.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>unhide</name>
			<script>player.unhide = true
send('unhide')

common.onNextEvent(tfe.events.ROOM_CHANGED, function ()
  player.unhide = nil
end)</script>
			<command></command>
			<packageName></packageName>
			<regex>^unhide$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>farscan</name>
			<script>-- first check if we need to re-up BM
common.getAffects( function (affects)
  if (not affects["You can see a great distance."]) then
    common.getReagents('a shard of glass', 1, function()
      send('cast far-sight')
    end)
  end
end)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^farscan$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>xerotes</name>
			<script>if player.skills.xerotes and player.skulls.xerotes &gt;= 10 and not druid.skipXerotes[gmcp.Room.Info.wind] then
  cecho('\n\n&lt;green&gt;XEROTES:&lt;white&gt; recasting xerotes as wind was: ' .. gmcp.Room.Info.wind  .. '\n\n')
  send('cast xerotes')
end
</script>
			<command></command>
			<packageName></packageName>
			<regex>^xerotes</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>timecheck</name>
			<script>
local sleepTrig = tempRegexTrigger([[^You cannot do that while sleeping\.$]], function()
  send('stand &amp; observe &amp; sleep')
end, 1)

tempRegexTrigger([[^=\s+(\S.*?)\s+\|\s*(\S.*?)\s*=]], function()
  display(matches[2], matches[3])
  killTrigger(sleepTrig)
end,1)
send('observe')
</script>
			<command></command>
			<packageName></packageName>
			<regex>timecheck</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>go to druid ways</name>
			<script>druid.landwalk()</script>
			<command></command>
			<packageName></packageName>
			<regex>^gw$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>respell</name>
			<script>local target = matches[2] or 'gstat'

if (target == '') then target = 'gstat' end

njs50.respell(player.buffs, {
  target = target, 
  callback = function()
    -- mojune.reportMana()
  end
})

-- expandAlias('xerotes')
</script>
			<command></command>
			<packageName></packageName>
			<regex>^respell ?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>improve aqua spell</name>
			<script>
local spell = 'aqueous surge'

if (player.skills[spell] &lt; 7) then

  send('stand &amp; rem diam.ring &amp; queue wea diam.ring &amp; queue cast ' .. spell .. ' self &amp; queue drink cauldron &amp; queue sit couch &amp; queue sleep')
    
else
    
  cecho('\n\n&lt;green&gt; ' .. spell .. ' is maxxed(ish), hooray!\n')
end


</script>
			<command></command>
			<packageName></packageName>
			<regex>^imp-aqua$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>resetDruidSpellImproves</name>
			<script>improves.spellList = {
  'dry',
  -- 'desiccate',
  'gale',
  -- 'blaze',
  'gloom',
  -- 'earthen fist',
  -- 'undergrowth',
  -- 'whirlwind',
  
  -- prob only want at 7
  -- 'aqueous spirit',
  -- 'healing rain',
  
  -- AOE no target required section
  -- 'impede',
  -- 'squall',
  -- 'storm', 
  -- 'anemogenesis',
  -- 'xerotes',
  -- 'healing rain',
  -- 'healing rain',
  -- 'tornado',
  -- 'tempest',
  
  'aqueous surge',
  'viper nest',
  
}</script>
			<command></command>
			<packageName></packageName>
			<regex>^rdsi$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>improveNonCombat</name>
			<script>druid.improveNonCombat()</script>
			<command></command>
			<packageName></packageName>
			<regex>^improveNonCombat$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>^prepFull</name>
			<script>local cmd = matches[2]

druid.getFull(function()
  expandAlias('gstat ready (' .. player.name .. ')')
end)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(pfull|prepFull)\s?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>^prepFree</name>
			<script>local cmd = matches[3]

druid.prepFree(function()
  expandAlias('gstat ready (' .. player.name .. ')')
end)</script>
			<command></command>
			<packageName></packageName>
			<regex>^(prepFree|pfree)\s?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>get ready</name>
			<script>player.postStormCheck(function()
  send('gstat ready (' .. player.name .. ')')
end)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^getReady$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>sleep|rest</name>
			<script>druid.rest(matches[2])</script>
			<command></command>
			<packageName></packageName>
			<regex>^(sl|rest)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>stand</name>
			<script>druid.stand()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(st)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>up - in a hurry!</name>
			<script>cecho('\n&lt;green&gt;TEAMWORK: &lt;white&gt;command to stand!')

player.gettingFull = nil

send('stand')
resetGear()

-- cancel any prep timers/triggers

if (common.checkFullTimer) then 
	killTimer(common.checkFullTimer)
	common.checkFullTimer = nil
end

druid.stand(function ()
	send('gstat Ready (' .. player.name .. ')')
	druid.reportMana()
end)

</script>
			<command></command>
			<packageName></packageName>
			<regex>^upp$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>storm</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>post-storm-check</name>
				<script>
player.postStormCheck()

</script>
				<command></command>
				<packageName></packageName>
				<regex>^p$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>storm</name>
				<script>
local cmd = ''
if (matches[2] ~= '') then
  cmd = rex.gsub(matches[2], [[ &amp; $]], '')
  send(cmd)

  if (rex.find(cmd, [[(?i)^(n|e|s|w|u|d|north|east|south|west|up|down)]])) then
    cecho('\n&lt;green&gt;STORM:&lt;white&gt; moving and casting, fancy!\n')
    player.ss.casting = nil
    player.ss.storm_active = nil
  end
  
end



player.ss.cast()

if (matches[3] ~= '') then
  cmd = rex.gsub(matches[3], [[^ &amp; ]], '')
  send(cmd)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>(?i)^(.* &amp; |)storm(| &amp; .*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>move + storm</name>
				<script>expandAlias(matches[2] .. ' &amp; storm')</script>
				<command></command>
				<packageName></packageName>
				<regex>^s([neswud])$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>defer loading farmer scripts</name>
			<packageName></packageName>
			<script>farmer = farmer or {}

farmer.afterCommonLoaded = function(cb)

  if (not farmer.configure) then
    registerAnonymousEventHandler('njs50SharedLoaded', cb, true)
  else
    cb()
  end
  
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>augmenting</name>
			<packageName></packageName>
			<script>druid = druid or {}

druid.augRooms = {
  jungle = 5821,
  beach = 5874,
  cave = 5860,
  forest = 5850,
  bamboo = 5837,
  tundra = 5817,
  desert = 5855,
  hills = 5801,
  field = 5802,
  swamp = 5803,
  mountain = 5800
}


druid.augRoom = 5117

druid.augment = function(spell, terrain, target, cb, fcb)

  -- spell = ivy or vine (armor), vine = higher level

  local vnum = druid.augRooms[string.lower(terrain)]
  
  local startRoom
  
  if (gmcp.Room.Info.num == druid.augRoom) then
    if (vnum) then
    
      druid.landwalk(function()
        tfe.gotoRoom(vnum, function()
          common.onClear(function()
            
            njs50.cast(spell .. ' armor', {
              target = target,
              callback = function()
                tfe.gotoRoom(druid.augRoom, cb)
              end,
              failCallback = fcb,
            })
            
          end)
        end)
      end)
      
    else
      return fcb('invalid terrain ' .. terrain)
    end
  else
    return fcb('only augmenting from med xroads')
  end


end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>druid junk</name>
			<packageName></packageName>
			<script>druid = druid or {}

druid.skipXerotes = {
  gale = true,
  ["strong gale"] = true,
  storm = true,
  ["violent storm"] = true,
  hurricane = true,
}

druid.landwalk = function(cb)
    
  local landwalkTerrains = {
    ['47'] = "Dark Bamboo",
    ['42'] = "Bamboo Forest",
    ['53'] = "Forest",
    ['56'] = "Jungle",
    ['25'] = "Rainforest",
    ['35'] = "Tundra",
    ['52'] = "Field",
    ['43'] = "Beach",
    ['48'] = "Desert",
    ['45'] = "Cave",
    ['55'] = "Hills",
    ['20'] = "Mountain",
    ['31'] = "Swamp",
    
    -- ffs. random terrains
    ['100'] = "Sandy Cavern",
  }
  
  
  -- start with current room
  local checkRooms = {
    { vnum = gmcp.Room.Info.num, cost = 0, terrain = landwalkTerrains[tostring(getRoomEnv(gmcp.Room.Info.num))] }
  }
  
  local checkedRooms = {}
  checkedRooms[tostring(gmcp.Room.Info.num)] = true
  
  local foundWays = {}
  if (checkRooms[1].terrain) then
    table.insert(foundWays, checkRooms[1])
  end
  
  
  local getAdjacentRooms = function(rooms, checkedRooms, foundWays)
    
    local newRooms = {}
    
    for i,room in pairs(rooms) do
      
      for exitDir, newVnum in pairs(getRoomExits(room.vnum)) do
      
        if (not checkedRooms[tostring(newVnum)]) then
          
          checkedRooms[tostring(newVnum)] = true
          
          -- if this room is locked then we need to ignore it
          if (not roomLocked(newVnum)) then
          
            local thisRoom = {
              vnum = newVnum, 
              cost = room.cost + getRoomWeight(newVnum), 
              terrain = landwalkTerrains[tostring(getRoomEnv(newVnum))],
            }
            table.insert(newRooms, thisRoom)
            if (thisRoom.terrain) then
              table.insert(foundWays, thisRoom)
            end
            
          end
        end
      
      end
      
    end
    
    return newRooms, checkedRooms, foundWays
  
  end
  
  local room_count = 0;
  
  while (#foundWays == 0 and room_count &lt; 100) do
    room_count = room_count + 1
    checkRooms, checkedRooms, foundWays  = getAdjacentRooms(checkRooms, checkedRooms, foundWays)
  end
  -- 
  -- display(checkRooms, checkedRooms, foundWays, room_count)
  -- cecho('\n\n----\n\n')
  
  table.sort(foundWays, function(a,b) return a.cost &lt; b.cost end)
  
  if (#foundWays &gt; 0) then
    
    cecho('\n\n&lt;green&gt;MAPPER:&lt;white&gt; closest landwalk terrain is ' .. tostring(room_count) .. ' rooms away\n')
  
    common.getAffects( function (affects)
    
      local clw = function()
        -- murder.groupDoAck('cast landwalk', function() 
          njs50.cast('landwalk', {
            callback = function()
              -- for some reason the room hasn't updated for a while after the spell is cast
              -- waiting for a room change if we aren't in the ways already
              if (gmcp.Room.Info.area == "The Ways") then
                if (cb) then cb() end
              else
                -- wait for the room to change
                common.onNextEvent(tfe.events.ROOM_CHANGED, function (evt, args)
                  if (cb) then cb() end
                end)              
              end

            end
          })        
        -- end)
      end
      
      local clb = function()
 
         if (not affects["You are able to bind lands together."]) then
          -- murder.groupDoAck('cast landwalk', function() 
            njs50.cast('landbinding', { callback = clw })
          -- end)
        else
          clw()
        end     
      
      end
    
      if (gmcp.Room.Info.num == foundWays[1].vnum) then
        clb()
      else
        tfe.gotoRoom(foundWays[1].vnum, clb)
      end

    end)  
  
  else
    cecho('\n\n&lt;red&gt;MAPPER:&lt;white&gt;; no path found to landwalkable terrain\n')
  end

end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>storm-state</name>
			<packageName></packageName>
			<script>farmer.afterCommonLoaded(function ()
  
  player = player or {}
  player.ss = player.ss or {}

  player.ss.events = player.ss.events or {}
  player.ss.events.STORM_ENDED = 'druid: storm ended'

  
  if (player.ss.roomChangeWatch) then
    killAnonymousEventHandler(player.ss.roomChangeWatch)
    player.ss.roomChangeWatch = nil
  end
  
  player.ss.roomChangeWatch = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, function ()
    if player.stormEnabled then
      cecho('\n&lt;green&gt;storm state:&lt;white&gt; room change #' .. tostring(gmcp.Room.Info.num))
      for spell, count in pairs(player.prepped) do
        cecho(', ' .. spell .. ': ' .. tostring(count) .. ' ') 
      end
      cecho('\n')
  
      player.ss.casting = nil
      player.ss.storm_active = nil
    end
  end)
  
  
  player.ss.onStormDone = function(cb)
    
    if (not player.ss.storm_active and not player.ss.casting) then
      cb()
    else
      common.onNextEvent(player.ss.events.STORM_ENDED, cb)
    end
    
  end

  player.ss.cast = function(clearQueue)
    
    if player.stormEnabled then
    
      local abortTrig, abortedPrep
      
      if (clearQueue) then
            
        abortTrig = tempRegexTrigger([[^You abort preparing (.+)\.$]], function()
          abortedPrep = matches[2]
          cecho(' &lt;green&gt;&lt;--- aborted cast. recast on clear\n')
        end)
      
        player.ss.casting = nil
        player.ss.storm_active = false
        send('+') 
      end
    
    
      if (player.ss.storm_active) then
        cecho('\n&lt;green&gt;storm state:&lt;white&gt; storm already active, not recasting\n')
        return false
      end
      
      if (player.ss.casting) then
        cecho('\n&lt;green&gt;storm state:&lt;white&gt; storm already being cast, not recasting\n')
        return false
      end
    
      player.ss.casting = true
      
      njs50.cast(player.stormSpell, {
        callback = function()
          cecho('\n&lt;green&gt;storm state:&lt;white&gt; cast storm spell\n')
          player.ss.casting = nil
          player.ss.storm_active = true 
          
          if (clearQueue) then
            if (abortTrig) then killTrigger(abortTrig) end
            if (abortedPrep) then
              common.onClear(function()
                send('prepare ' .. abortedPrep)
              end)
            end
          end     
        end,
        failCallback = function()
          cecho('\n&lt;green&gt;storm state:&lt;white&gt; storm spell disrupted\n')
          if (abortTrig) then killTrigger(abortTrig) end
          -- if it was disrupted due to room change don't auto recast
          player.ss.casting = nil     
        end
      })
  
      return true
    end
  
  end
  
  cecho('\n&lt;green&gt;storm state:&lt;white&gt; loaded\n')

end)</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>repop check</name>
			<packageName></packageName>
			<script>druid = druid or {}

-- A silver coin lies here, forgotten.
 
druid.waysRepopCheckCoin = function(direction, cb)
  common.checkRepopByDrop(direction, [[^\S+ \w+ coins? lies?]], cb)
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>prep etc</name>
			<packageName></packageName>
			<script>druid = druid or {}

druid.reportMana = function ()
	local pdata = group.data[player.name]
  local manaPct = math.ceil((pdata.mp / pdata.mp_max * 100))
  local cmd = 'gstat mana at ' .. tostring(manaPct) .. '%'
  if (player.stormSpell and player.stormSpell ~= '') then
    local ct = player.prepped[player.stormSpell] or 0
    cmd = cmd .. ', ' .. tostring(ct) .. ' ' .. player.stormSpell
  end
  send(cmd)
end



druid.prepFree = function(cb)
  
  -- 
      -- 
      -- cmd = cmd .. 'cast xerotes &amp; '
    -- end
    

  
  njs50.respell(player.buffs, {
    target = 'gstat',
    callback = function()
       prepFree(player.stormSpell, player.reserveMana, player.prepStormAmount, function()
        if (player.skills.xerotes and player.skills.xerotes &gt;= 10 and not druid.skipXerotes[gmcp.Room.Info.wind]) then
          njs50.cast('xerotes', {
            callback = function ()
              druid.reportMana()
              if (cb) then cb() end
            end
          })        
        else
         	tempTimer(3, function ()
            druid.reportMana()
            if (cb) then cb() end
        		end)      
        end

      end)   
    end
  })     

end


-- 
-- 
-- player.getFull = function(cb)
  -- 
  -- player.gettingFull = player.gettingFull or false
  -- expandAlias('xerotes')
  -- 
  -- 
  -- local fullEnough = common.fullEnough()
  -- 
  -- if (fullEnough and player.mp_max &lt;= player.reserveMana) then
  -- 
  	  -- cecho('\n&lt;green&gt;PREP: &lt;white&gt;close enough to full\n')
    -- common.prep(player.stormSpell, player.prepStormAmount, function()
      -- if (cb) then cb() end  
    -- end)   
  -- 
  -- elseif (not player.gettingFull) then
  -- 
    -- cecho('\n&lt;green&gt;PREP: &lt;white&gt;getting full\n')
  -- 
  	  -- player.gettingFull = true
    -- send('cast dowse') 
    -- send('dismount')
    -- send('ef &amp; dw')
    -- 
    -- if ((group[player.name].hp_max - group[player.name].hp) &gt; 150) then
      -- send('cast ' .. player.healSpell)
    -- end
  -- 
    -- tempTimer(4, function ()
    -- 
      	-- send('hide &amp; sit couch &amp; sit chair &amp; sit pad &amp; sit boulder &amp; sit bench')
      	-- mojune.rest('sleep', function()
        	-- common.onFull( function ()
          -- 
          -- mojune.stand(function()
          -- 
            -- common.prep(player.stormSpell, player.prepStormAmount, function()
              -- -- send('mount')
            		-- tempTimer(3, function ()
          				-- player.gettingFull = false
                  -- mojune.reportMana()
                -- if (cb) then cb() end
            		-- end)    
            -- end)
          -- end)
  -- 
        -- end)
      -- end)
    -- end)
  -- 
  -- else
    	-- cecho('\n&lt;green&gt;PREP: &lt;white&gt;already getting full\n')
    -- if (cb) then cb() end
  -- end
  -- 
-- end


druid.getFull = function (callback)

  if (not (player.gettingFull and player.position == 'sleeping')) then 
    player.gettingFull = true
    
    if (player.healSpell and (group.data[player.name].hp_max - group.data[player.name].hp) &gt; 125) then
      send('cast ' .. player.healSpell)
    end

    expandAlias('ef &amp; dw &amp; remove ' .. player.pack)
    
    druid.rest('sleep', function () 
      
      common.onFull( function ()
        druid.stand( function () 
          
          druid.prepFree(function ()
          
            player.gettingFull = nil
            -- expandAlias('gstat ready (' .. player.name .. ')')
            -- druid.reportMana()
            
            if (callback) then callback() end
            
          end)
        
        end)
        
      end)
    
    end)
  
  else	
    cecho('\n&lt;green&gt;PREP: &lt;white&gt;already getting full\n')
  end
	
end  



druid.rest = function (cmd, callback) 
	
	send('stand &amp; remove ' .. player.pack)
	
	equipPartial('sleep', function ()
    send('hide &amp; sit rug &amp; sit mat &amp; sit chair &amp; sit couch &amp; sit sofa &amp; sit bed &amp; sit bench')
		send(cmd)
		if (callback ~= nil) then callback() end
	end)

end


druid.stand = function (callback)

	send('stand &amp; remove blanket &amp; gs &amp; put blanket ' .. player.pack)
	resetGear(function () 
		-- send('ps')
		if (callback ~= nil) then callback() end
	end)
  	
end





druid.stormStepAction = function(cb, options)
  
  options = options or {}
  
  options.skipHealAmount = options.skipHealAmount or 300
  options.sleepForMana = options.sleepForMana or false
    
  player.postStormCheck(cb, options)
  
end
  
 
player.postStormCheck = function(cb, options)

  player.sscb = player.sscb or {}

  if cb and not table.contains(player.sscb, cb) then
    table.insert(player.sscb, cb)
  end

  local execCallback = function()
    player.sscb = player.sscb or {}
    player.pendingPostStormCheck = nil
    for idx, fn in ipairs(player.sscb) do
      fn()
    end
    player.sscb = nil    
  end

  if (player.pendingPostStormCheck ~= nil) then  
    cecho('\n\n&lt;red&gt;PREP:&lt;white&gt; post storm check is already pending\n') 
    return
  end
  player.pendingPostStormCheck = true
  

  options = options or {}
  
  options.skipHealAmount = options.skipHealAmount or 250
  
  
  options.sleepForMana = options.sleepForMana or false
  
  cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; beginning post storm check\n') 
    
  player.prepped[player.stormSpell] = player.prepped[player.stormSpell] or 0  
    
  druid.makeItRain({ 
    skipAmount = options.skipHealAmount, 
    whileWaiting = function(cb2)

      local prepAmount = math.floor((player.mp - player.reserveMana) / player.stormSpellReserveAmount)
      
      if (prepAmount == 0) then 
        cb2()
      else
        common.prep(player.stormSpell, player.prepped[player.stormSpell] + prepAmount, cb2)
      end
      
    
    end,
    callback = function() 

      njs50.respell(player.buffs, {
        target = target, 
        failCallback = function()
          cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; post storm respell failed, trying again in 10\n')
          tempTimer(10, function()
            player.pendingPostStormCheck = nil
            return player.postStormCheck(nil, options)
          end)
        end,
        callback = function()
     

          if ((player.mp &gt; (player.reserveMana + player.stormSpellReserveAmount)) and
            (player.prepped[player.stormSpell] &lt; player.minPreppedStormSpells)
          ) then
            
            player.prepped[player.stormSpell] = player.prepped[player.stormSpell] or 0
          
            -- mana is available to prep, prep 1
            common.prep(player.stormSpell, player.prepped[player.stormSpell] + 1, function()
            
              if player.prepped[player.stormSpell] &lt; player.minPreppedStormSpells then
                
                cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; prepping another in 5\n') 
                player.pendingPostStormCheck = nil
                return player.postStormCheck(nil, options)
                
              else  
                
                player.pendingPostStormCheck = nil
                druid.reportMana()
                execCallback()  
                cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; ready to roll\n') 
                    
                
              end
      
            end)
          
          else
          
          
          
          
            -- got enough prepped / free
            if (player.mp &gt; player.reserveMana and 
              player.prepped[player.stormSpell] and
              player.prepped[player.stormSpell] &gt;= player.minPreppedStormSpells) then
              
              cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; ready to roll\n') 
              execCallback()    
              
            else
            
              -- need to get some more juice
              


              if (options.sleepForMana and (gmcp.Char.Vitals.maxen - gmcp.Char.Vitals.en) &gt; 120 ) then
              
                cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; getting full mana (once any storms end)\n')
                player.ss.onStormDone(function()
                  druid.getFull(function()
                    execCallback()
                  end)
                end)
              
              else
              
                -- required mana for min spells
                -- local spellsNeeded = (player.minPreppedStormSpells - (player.prepped[player.stormSpell] or 0))
                -- local reqMana = player.stormSpellCost * spellsNeeded + player.reserveMana
                -- cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; waiting for mana to regen for ' .. tostring(spellsNeeded) .. ' storm spells\n')

                -- if (gmcp.Char.Vitals.en &gt; reqMana) then
                  -- druid.prepFree(cb)
                -- end

                cecho('\n\n&lt;green&gt;PREP:&lt;white&gt; waiting for mana to regen (15s)\n')
                tempTimer(15, function()
                  player.pendingPostStormCheck = nil
                  return player.postStormCheck(nil, options)
                end, 'waiting on mana for post-storm-check')
                
              end
            
            end
            
          
          end
          
         
        end
      }) 
      
      
    end
  })
  
  


end



-- these seem to be  refrenced randomly all over the show...
player.prepFull = druid.getFull
player.getFull = druid.getFull
player.prepStorms = player.prepStorms or 'none'
player.prepFree = druid.prepFree</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>healing</name>
			<packageName></packageName>
			<script>druid = druid or {}

druid.healState = druid.healState or {}

druid.healState.events = druid.healState.events or {}

druid.healState.events.HEAL_STARTED = 'druid: heal started'
druid.healState.events.HEAL_ENDED = 'druid: heal ended'


druid.onHealEnd = function(cb)

  local rwatch, rewatch
  
  -- stop waiting for the end if we change rooms
  rwatch = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, function ()
    killAnonymousEventHandler(rewatch)
    cb()
  end, true)
  
  rewatch = registerAnonymousEventHandler(druid.healState.events.HEAL_ENDED, function ()
    killAnonymousEventHandler(rwatch)
    cb()
  end, true)
  
end


druid.castHeal = function(options)
  
  options = options or {}
  
  local resolveCallbacks = function()
  
    local waitingDone = true
    local rainDone = false
    
    if (options.whileWaiting) then
      waitingDone = false
      options.whileWaiting(function()
        waitingDone = true
        if (rainDone and options.callback) then
          options.callback()
        end
      end)
      
    end   
   
    druid.onHealEnd(function()
      cecho('\n&lt;green&gt;DRUID:&lt;white&gt; ' .. player.healSpell .. ' ended!\n\n')
      if (options.callback and waitingDone) then 
        options.callback()
      else
        rainDone = true
      end    
    end)  
    
  end


  -- skip if we already have one queued / in progress
  if (druid.healState.casting or druid.healState.healing) then
    cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; attempted to heal while heal already in progress\n')
    resolveCallbacks()
    return
  end

  local retry = function ()  
    tempTimer(5, function()
      druid.makeItRain(options)
    end, 'healing retry')
  end

  if (player.healSpellCost &gt; player.mp) then
    
    cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; not enough mana for ' .. player.healSpell .. ', waiting 5s\n')
    retry()
  
  else
  
    druid.healState.casting = true
    
    njs50.cast(player.healSpell, {
      callback = function()
        resolveCallbacks()
      end,
      failCallback = function(reason)
      -- display(reason, 'wtf')
        if (reason == 'cast failed due to combat') then
          if (options.cancelOnCombat) then
            cecho('\n&lt;green&gt;DRUID:&lt;white&gt; failed to cast ' .. player.healSpell .. ' due to combat, skipping\n')
          else
            cecho('\n&lt;red&gt;DRUID:&lt;white&gt; failed to cast ' .. player.healSpell .. ', trying again after combat\n')
            common.onNextEvent(common.events.COMBAT_ENDED, function()
              druid.castHeal(options)
            end)
          end
       else
          cecho('\n&lt;red&gt;DRUID:&lt;white&gt; failed to cast ' .. player.healSpell .. ', trying again in 5s\n')
          retry()
        end
      end
    
    })
  end
end

druid.healCastStart = function()
  cecho('&lt;green&gt; &lt;-- heal casting\n')
  druid.healState.casting = true
end

druid.healStarted = function()
  cecho('&lt;green&gt; &lt;-- heal started\n')
  druid.healState.casting = nil
  druid.healState.healing = true
  raiseEvent(druid.healState.events.HEAL_STARTED)
end

druid.healEnded = function()
  cecho('&lt;green&gt; &lt;-- heal ended\n')
  druid.healState.healing = nil
  raiseEvent(druid.healState.events.HEAL_ENDED)
end

druid.healInterrupted = function()
  cecho('&lt;green&gt; &lt;-- heal interrupted\n')
  druid.healState.casting = nil
end

druid.healCombatFail = function()
  cecho('&lt;green&gt; &lt;-- heal failed (combat)\n')
  druid.healState.casting = nil
end


-- add some event watchers

if (druid.healState.roomChangeWatch) then
  killAnonymousEventHandler(druid.healState.roomChangeWatch)
  druid.healState.roomChangeWatch = nil
end

druid.healState.roomChangeWatch = registerAnonymousEventHandler(tfe.events.ROOM_CHANGED, function ()
  druid.healState.casting = nil
  druid.healState.healing = nil
end)


druid.makeItRain = function(options)

  options = options or {}

  if (options.skipAmount) then
    
    local canSkip = true
    
    for name in pairs(group.members) do 
      -- display(name, group[name].hp_max - group[name].hp)
      -- require at least 60% hp
      if (
        ((group.data[name].hp_max - group.data[name].hp) &gt; options.skipAmount) or
        (group.data[name].hp / group.data[name].hp_max &lt; 0.6)
      ) then
        canSkip = false
      end
      cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; ' .. name .. ' is ' .. tostring(group.data[name].hp) .. ' of ' .. tostring(group.data[name].hp_max) .. 'hp!\n')
    end
    
    if (canSkip) then
      cecho('\n&lt;green&gt;DRUID:&lt;white&gt; healthy enough to skip ' .. player.healSpell .. '!\n')
      if (options.callback) then options.callback() end
      return
    end
    
  end
  
  druid.castHeal(options)


end


druid.healGroup = function(options)

  options = options or {}
  
  options.skipAmount = options.skipAmount or 100
  options.callback = options.callback or function() end
  
  canSkip = true
  

  for name in pairs(group.members) do 
    if (
      ((group.data[name].hp_max - group.data[name].hp) &gt; options.skipAmount) or
      (group.data[name].hp / group.data[name].hp_max &lt; 0.6)
    ) then
      canSkip = false
    end
    cecho('\n&lt;orange&gt;DRUID:&lt;white&gt; ' .. name .. ' is ' .. tostring(group.data[name].hp) .. ' of ' .. tostring(group.data[name].hp_max) .. 'hp!\n')
  end

  -- going to keep casting heals til we can skip healing
  if not canSkip then
    druid.castHeal({callback = function()
      druid.healGroup(options)
    end})  
  else
    options.callback()
  end
  -- 


end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>mojune.player.config</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

player = player or {}
player.scripts = player.scripts or {}

-- nb: must match exactly. i.e don't forget the capital letter
player.scripts.DefaultDruid = function ()

	player.bag = 'snatch'
	player.pack = 'ReturnToMojune'
	player.reagentBag = 'ReturnToMojune'
	player.gearSet = 'default'
	player.vessel = 'slick.green.waterskin'
	player.caster = false
	player.hasFoodBasket = true
  
  player.getAttackCommand = function(target)
    return 'kill ' .. target
  end
  
  player.autoAttack = function(target)
    send(player.getAttackCommand(target))
  end  

end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>improves</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>improves</name>
				<packageName></packageName>
				<script>druid = druid or {}

druid.improveNonCombat = function(cb)
  
  cb = cb or function() end
  
  local hpItem = 'serp.ring'
  local bandage = 'a simple bandage'
  
  local improveThings = {
    
    -- this one is a bit shit because you can't keep doing it in the same room
    -- dowse = { cmd = 'cast dowse &amp; |fill cant puddle &amp; |empt cant &amp; |fill cant puddle &amp; |empt cant', level = 7},
    
    bandage = { bandage = true, cmd = 'bandage self', reagent = 'a simple bandage', level = 10 },
    compress = { bandage = true, cmd = 'compress self', reagent = 'a clump of herbs', level = 10 },
    poultice = { bandage = true, cmd = 'poultice self', reagent = 'a thick aloe leaf', level = 10 },
    salve = { bandage = true, cmd = 'poultice self', level = 7 },
    ['healing mist'] = { heal = true, cmd = 'cast healing mist', level = 7 },
    ['healing rain'] = { heal = true, cmd = 'cast healing rain', level = 10 },
    
    impede = { cmd = 'cast impede', level = 10},
    
    fireflies = { cmd = 'remove gold.ball &amp; | cast fireflies &amp; | remove fireflies &amp; | wear gold.ball', level = 10},
    
    squall = { cmd = 'prep squall &amp; |cast squall', level = 10},
    storm = { cmd = 'prep storm &amp; |cast storm', level = 10},
    blizzard = { cmd = 'prep blizzard &amp; |cast blizzard', level = 10},
    tornado = { cmd = 'prep tornado &amp; |cast tornado', level = 7},
    tempest = { cmd = 'prep tempest &amp; |cast tempest', level = 10},
    
    anemogenesis = { cmd = 'cast anemogenesis', level = 10},
    xerotes = { cmd = 'cast xerotes', level = 10},
    
    darklight = { cmd = 'remove gold.ball &amp; cast darklight &amp; |remove darklight &amp; |wear gold.ball', level = 10},
    
  }
  
  -- display(thing, data)
  local skipThing = true
  
  -- find thing to imp
  for thing, data in pairs(improveThings) do 
   
    if (
      player.lastImproveSkill == nil or 
      thing == player.lastImproveSkill
    ) then
      skipThing = false
    end
    
    if ( not skipThing and
         player.lastImproveSkill ~= thing and
         player.skills[thing] and 
         player.skills[thing] &gt; 0 and 
         player.skills[thing] &lt; data.level 
    ) then
    
      cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; lets improve ' .. thing .. '\n\n')
  
      
      if (data.bandage) then
  
        common.getReagents(data.reagent, 1, function()
          common.getReagents(bandage, 1, function()
            send('|remove ' .. hpItem .. ' &amp; |wear ' .. hpItem .. ' &amp; |sit')
            send('|' .. data.cmd .. ' &amp; |wait 4 &amp; |stand')
            cb()
          end, function()
            cecho('\n\nOut of ' .. bandage .. '!!!\n\n')
          end)
        end, function()
          cecho('\n\nOut of ' .. data.reagent .. '!!!\n\n')
        end)
  
      elseif (data.heal) then
  
        send('|remove ' .. hpItem .. ' &amp; |wear ' .. hpItem .. ' &amp; |' .. data.cmd)
        cb()
      
      else
        send('|' .. data.cmd)
        cb()
      end
  
      player.lastImproveSkill = thing
      
      
      return
  
    end
  
  end
  
  if (player.lastImproveSkill ~= nil) then
    player.lastImproveSkill = nil
    druid.improveNonCombat(cb)
  else
    cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; nothing left to improve!!!\n\n')
    cb()
  end
  
end

druid.improveCombat = function(target)
  
  cb = cb or function() end
  
  local improveThings = {
    
    -- need to keep moving while doing this. bleh
    dowse = { cmd = 'cast dowse &amp; |fill cant puddle &amp; |empt cant &amp; |fill cant puddle &amp; |empt cant &amp; |cast gale', level = 7},
    
    -- darkness
    nocturne = { cmd = 'cast nocturne', level = 7},
    gloom = { cmd = 'cast gloom', level = 10},
    shadowstrike = { cmd = 'cast shadowstrike', level = 7},
    ['veil of darkness'] = { cmd = 'cast veil of darkness', level = 10},
    
    -- for healing
    ['aqueous surge'] = { cmd = 'cast aqueous surge', level = 7},
    ['aqueous spirit'] = { cmd = 'cast aqueous spirit', level = 7},
    
    -- wind
    gust = { cmd = 'cast gust', level = 7},
    ['wind shear'] = { cmd = 'cast wind shear', level = 7},
    gale = { cmd = 'cast gale', level = 10},
    whirlwind = { cmd = 'cast whirlwind', level = 10},
    
    -- storm
    squall = { cmd = 'prep squall &amp; |cast squall &amp; |look', level = 10},
    storm = { cmd = 'prep storm &amp; |cast storm &amp; |look', level = 10},
    blizzard = { cmd = 'prep blizzard &amp; |cast blizzard &amp; |look', level = 7},
    tornado = { cmd = 'prep tornado &amp; |cast tornado &amp; |look', level = 7},
    tempest = { cmd = 'prep tempest &amp; |cast tempest &amp; |look', level = 10},
    
    
    -- util
    undergrowth = { cmd = 'cast undergrowth', level = 10},
    
    -- drying (for xerotes)
    dry = { cmd = 'cast dry', level = 10},
    parch = { cmd = 'cast parch', level = 7},
    desiccate = { cmd = 'cast desiccate', level = 7},
    
    -- aoe (optional)
    blizzard = { cmd = 'prep blizzard &amp; |cast blizzard &amp; |sigh', level = 7},
    
  }
  
  -- display(thing, data)
  local skipThing = true
  
  -- find thing to imp
  for thing, data in pairs(improveThings) do 
   
    if (
      player.lastImproveSkill == nil or 
      thing == player.lastImproveSkill
    ) then
      skipThing = false
    end
    
    if ( not skipThing and
         player.lastImproveSkill ~= thing and
         player.skills[thing] and 
         player.skills[thing] &gt; 0 and 
         player.skills[thing] &lt; data.level 
    ) then
    
      cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; lets improve ' .. thing .. '\n\n')
  
      player.lastImproveSkill = thing
      
      return data.cmd .. ' ' .. target
  
    end
  
  end
  
  if (player.lastImproveSkill ~= nil) then
    player.lastImproveSkill = nil
    return druid.improveCombat(target)
  else
    cecho('\n&lt;green&gt;IMPROVE:&lt;white&gt; nothing left to improve!!!\n\n')
    return ''
  end
  
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>spell-improve-path</name>
				<packageName></packageName>
				<script>
farmer.afterCommonLoaded(function ()

  
  local targets = {
    ["wild-eyed.goblin"] = true,
    ["small.homonculou"] = true,
    ["large.slug"] = true,
    ["tunnel.worm"] = true,
    ["small.homonculi"] = true,
    ["small.homoncul"] = true,
    ["screech.bat"] = true,
    ["tiny.black.ooze"] = true,
    ["massive.slug"] = true,
    ["giant.black.beetle"] = true
  }
  
  
  local getImproveCommand = function(exit)
    
    if (improves.sawAction) then
      cecho('\n&lt;green&gt;IMPS:&lt;white&gt; waiting for action timer to cool down\n')
      return ''
    end
    
    
    if (exit and exit.firstTarget) then
        return improves.getImproveSpell() .. ' ' .. exit.firstTarget
    else
    	return ''
    end
    
  end
  
  -- set the names of targets to murder
  local steps = { 
  	
  	{ 
  		location = 20041, 
  		action = function (cb) 
        improves.sawAction = false
        -- send('alias *k ' .. improves.getImproveSpell())
        cb()
  		end 
  	},
  	
  	{ 
  		targets = targets,
    getKillCommand = getImproveCommand,  
  		waypoints = {20053, 20056, 37504, 37611, 37613, 37597, 37591, 37596, 37504, 20041}, --   at start to lengthen
      stepAction = function(cb)
        
        cecho('\n\n&lt;green&gt;ACTION: &lt;white&gt;step action!!! \n')
        
        if (improves.sawAction) then
          cecho('\n\n&lt;green&gt;ACTION: &lt;white&gt;recovering from exciting action!!!!\n')
          -- send('alias *k ' .. improves.getImproveSpell())
          tempTimer(3, function()
            expandAlias('sl')
          end)
          
          tempTimer(44, function ()
            expandAlias('st')
            cecho('\n\n&lt;green&gt;ACTION: &lt;white&gt;recovered. moving!!!!\n')
            improves.sawAction = false
            -- send('alias *k ' .. improves.getImproveSpell())
            send('scan')
            tempTimer(3, cb)
          
          end, 'action recovery')
        else
          cecho('\n\n&lt;green&gt;ACTION: &lt;white&gt;no action on this step :-[\n')
          tempTimer(0.25, function()
            cb()
          end)
        end
        
      end,
      action = function(cb)
        -- don't go to town until after any squalls etc have stopped...
        tempTimer(5, cb)
      end
  	},
    { 
      location = "20062",
      action = "buy all.tobacco"
    },
    { 
      location = "20027",
      action = "dep all.tobacco"
    },
    { 
      location = "20082",
      action = "drink soup &amp; drink soup &amp; drink soup &amp; drink soup"
    },
    { 
      location = "20001",
      action = "fill empty.slick"
    },
    { 
  		location = "20041", 
      action = player.getFull
    },
    
  }
  
  	
  local completeCallback = function ()
  	echo('spell imps is done...')
  	-- farmer.restart()
    tempTimer(10, farmer.restart)
  end
  		
  farmer.configure('spell.imps', steps, completeCallback, dropJunk)
  

end)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>trog.imps</name>
				<packageName></packageName>
				<script>farmer.afterCommonLoaded(function ()

local options = {

  longName = 'trog.imps',

  targets = {
    ["small.brown.troglodyte"] = 1,
    ["small.brown.troglodyt"] = 1,
    ["sallow-skinned.troglodyte"] = 1,
    ["sallow-skinned.troglodyt"] = 1,
  },

  onStopByTrigger = function ()
    send('stop was commanded - begin self destruct sequence')
  end,

}


local getImproveCommand = function(exit)
  
  if (improves.sawAction) then
    cecho('\n&lt;green&gt;IMPS:&lt;white&gt; waiting for action timer to cool down\n')
    return ''
  end
  
  
  if (exit and exit.firstTarget) then
      return druid.improveCombat(exit.firstTarget)
  else
  	return ''
  end
  
end

local steps = {

  {
    waypoints = {19348}, -- repop
    getKillCommand = getImproveCommand,
    action = function (cb)
      send('group -l ' .. player.name)
      improves.sawAction = false
      njs50bot.sleepUntilFull(function ()
        common.checkRepopByDrop(49250, [[^\S+ \w+ coins? lies?]], cb, 5)
      end)
    end,
  },
  
  {
    waypoints = {49250}, -- repop check room
    action = "drop silver.coin"
  },
  
  { 
    waypoints = {49296},
    getKillCommand = getImproveCommand,  
    action = "drink &amp; drink &amp; drink",
  },

  {
    waypoints = {49295, 49267, 49272, 49278, 49279, 49287, 49288, 49284, 49281, 49282, 49291, 49290, 49285}, -- path
    getKillCommand = getImproveCommand,  
  },

  {
    waypoints = {19348}, -- repop
    getKillCommand = getImproveCommand,  
  },


}

local completeCallback = function ()
  send('gstat trog.imps is done...')
  farmer.restart()
end

farmer.configure('trog.imps', steps, completeCallback, options)

end)


</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
